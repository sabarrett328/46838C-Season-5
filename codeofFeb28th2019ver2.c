#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    expBatt,        sensorAnalog)
#pragma config(Sensor, dgtl1,  encoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderR,       sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  right,          sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  front,          sensorSONAR_inch)
#pragma config(Sensor, dgtl9,  LED,            sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, limitswitch,    sensorDigitalIn)
#pragma config(Sensor, dgtl11, left,           sensorSONAR_inch)
#pragma config(Motor,  port2,           driveLF,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveLR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           shooterL,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           shooterR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           conveyor,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveRR,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           driveRF,       tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*               Description: Competition code for VEX EDR                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/////////////////////////////////////////////////////////////////////////////
// Rebel Alliance Robotics and Team 46838C Present
//
// Charlie 5.0 in * Turning Point *
//
// The 2018-19 Vex RC Competition Season
//
// Coming soon to a Event near you!
////////////////////////////////////////////////////////////////////////////

//*************************************************************************
//                                                                        *
//                          Global Variables                              *
//                                                                        *
//*************************************************************************
float fudge = 1; //real world fudge factor//
float dia = 4.1; //actual measured diameter of omni wheel//
float cir = dia*PI/fudge; //calc distance around wheel//
int decel = 360;// number of encoder counts to slow down when driving by distance
float turnfactor = 23;//scaling factor to turn encoder counts to degrees
int pause = 100; //pause for 1/10 of a second
int intakespeed = 125; //speed for running the intake correctly//
int conveyorspeed = 90; //speed for running the conveyor correctly//
int shooterspeed = 100; //speed for running the shooter correctly//
int autonProgram = 1;//tracker for which auton program to run
int park = 0; //variable for selecting to park in auton
int defense = 0;// variable for selecting defense shot
int loaded = 0;// tracker for number of balls loaded
// end of global variables



//*************************************************************************
//                                                                        *
//                          Robot Basic Functions                         *
//                          used for Autonomous routines                  *
//                                                                        *
//*************************************************************************

/////////////////////////////////
//
//   DRIVE FOR A DISTANCE
//
/////////////////////////////////
void drive(int speed,float dist) //function for driving a given distance at a given speed//
{
	float target = (360/cir)*dist; //calculate target encoder counts//

	SensorValue[encoderL] = 0; //reset encoder count to zero//
	SensorValue[encoderR] = 0; //reset encoder count to zero//

	//while encoder is less than decel dist(counts), run full speed
	if (dist > 0)
	{
		while (SensorValue[encoderL] < target-decel)
		{
			motor[driveLR] = speed;
			motor[driveRR] = speed;
			motor[driveLF] = speed;
			motor[driveRF] = speed;
		}

		//while encoder is less than target dist(counts), run at 50(slow to distance)
		while (SensorValue[encoderL] < target)
		{
			motor[driveLR] = 50;
			motor[driveRR] = 50;
			motor[driveLF] = 50;
			motor[driveRF] = 50;
		}

		// briefly reverse motors to brake
		motor[driveLR] = -50;
		motor[driveRR] = -50;
		motor[driveLF] = -50;
		motor[driveRF] = -50;
		wait1Msec(.7*pause);

		//turn off motors
		motor[driveLR] = 0;
		motor[driveRR] = 0;
		motor[driveLF] = 0;
		motor[driveRF] = 0;
	}
	else
	{
		while (SensorValue[encoderL] > target+decel)
		{
			motor[driveLR] = -speed;
			motor[driveRR] = -speed;
			motor[driveLF] = -speed;
			motor[driveRF] = -speed;
		}

		//while encoder is less than target dist(counts), run at 50(slow to distance)
		while (SensorValue[encoderL] > target)
		{
			motor[driveLR] = -50;
			motor[driveRR] = -50;
			motor[driveLF] = -50;
			motor[driveRF] = -50;
		}
		// briefly reverse motors to brake
		motor[driveLR] = 50;
		motor[driveRR] = 50;
		motor[driveLF] = 50;
		motor[driveRF] = 50;
		wait1Msec(pause);

		//turn off motors
		motor[driveLR] = 0;
		motor[driveRR] = 0;
		motor[driveLF] = 0;
		motor[driveRF] = 0;
	}
}// end drive for a distance



/////////////////////////////////
//
//   DRIVE FOR A TIME
//
/////////////////////////////////
void drivetime(int speed, int timems) // time based drive
{
	motor[driveLF] = speed;
	motor[driveLR] = speed;
	motor[driveRF] = speed;
	motor[driveRR] = speed;

	wait1Msec(timems);

	motor[driveLF] = 0;
	motor[driveLR] = 0;
	motor[driveRF] = 0;
	motor[driveRR] = 0;

}// end drive for time



/////////////////////////////////
//
//   DRIVE UNTIL A DISTANCE
//
/////////////////////////////////
void driveuntil(int speed, float dist)// druve until a distance is reached in front of the robot
{
	if (SensorValue[front] > dist)
	{
		motor[driveLF] = speed;
		motor[driveLR] = speed;
		motor[driveRF] = speed;
		motor[driveRR] = speed;
		while (SensorValue[front] > dist)
		{
			// drive until current position = or < desired position
		}

		//briefly reverse motors to brake motion
		motor[driveLF] = -speed;
		motor[driveLR] = -speed;
		motor[driveRF] = -speed;
		motor[driveRR] = -speed;
		wait1Msec(pause);

		//Stop motors
		motor[driveLF] = 0;
		motor[driveLR] = 0;
		motor[driveRF] = 0;
		motor[driveRR] = 0;
	}
	else if (SensorValue[front] < dist)
	{
		motor[driveLF] = -speed;
		motor[driveLF] = -speed;
		motor[driveLR] = -speed;
		motor[driveRF] = -speed;
		motor[driveRR] = -speed;
		while (SensorValue[front] < dist)
		{
			// drive until current position = or > desired position
		}

		// briefly reverse motors to brake motion
		motor[driveLF] = speed;
		motor[driveLR] = speed;
		motor[driveRF] = speed;
		motor[driveRR] = speed;
		wait1Msec(pause);

		//stop motors
		motor[driveLF] = 0;
		motor[driveLR] = 0;
		motor[driveRF] = 0;
		motor[driveRR] = 0;
	}
}// end drive until a distance



/////////////////////////////////////
//
//   TURN LEFT BY DEGREE (ENCODER)
//
/////////////////////////////////////
void turnLeftDeg(int degrees, int speed)
{
	//Reset encoders
	SensorValue[encoderL] = 0;
	SensorValue[encoderR] = 0;

	//Determine tickGoal
	int target = (turnfactor * degrees) / 10;

	//Start the motors in a left point turn.
	motor[driveLF] = -speed;
	motor[driveLR] = -speed;
	motor[driveRF] = speed;
	motor[driveRR] = speed;

	while(SensorValue[encoderR] < target || SensorValue[encoderL] > -target)
	{
		if(SensorValue[encoderR] > target)
		{
			motor[driveRF] = 0;
			motor[driveRR] = 0;
		}
		if(SensorValue[encoderL] < -target)
		{
			motor[driveLF] = 0;
			motor[driveLR] = 0;
		}
	}
	//Make sure both motors stop at the end of the turn.
	motor[driveLF] = 0;
	motor[driveLR] = 0;
	motor[driveRF] = 0;
	motor[driveRR] = 0;

}// end turn left by degree



/////////////////////////////////
//
//     TURN LEFT BY TIME
//
/////////////////////////////////
void turnlefttime(int speed,int timems) //clockwise turn
{
	//rotate right
	motor[driveLF] = -speed;
	motor[driveLR] = -speed;
	motor[driveRF] = speed;
	motor[driveRR] = speed;

	//wait time
	wait1Msec(timems);

	//turn off motors
	motor[driveLF] = 0;
	motor[driveLR] = 0;
	motor[driveRF] = 0;
	motor[driveRR] = 0;

}// end turn left by time



///////////////////////////////////
//
// TURN RIGHT BY DEGREE (ENCODER)
//
///////////////////////////////////
void turnRightDeg(int degrees, int speed)
{
	//Reset encoders
	SensorValue[encoderL] = 0;
	SensorValue[encoderR] = 0;

	//Determine tickGoal
	int target = (turnfactor * degrees) / 10;

	//Start the motors in a left point turn.
	motor[driveLF] = speed;
	motor[driveLR] = speed;
	motor[driveRF] = -speed;
	motor[driveRR] = -speed;

	while(SensorValue[encoderL] < target || SensorValue[encoderR] > -target)
	{
		if(SensorValue[encoderL] > target)
		{
			motor[driveLF] = 0;
			motor[driveLR] = 0;
		}
		if(SensorValue[encoderR] < -target)
		{
			motor[driveRF] = 0;
			motor[driveRR] = 0;
		}
	}
	//Make sure both motors stop at the end of the turn.
	motor[driveLF] = 0;
	motor[driveLR] = 0;
	motor[driveRF] = 0;
	motor[driveRR] = 0;

}// end turn right by degree



/////////////////////////////////
//
//   TURN RIGHT BY TIME
//
/////////////////////////////////
void turnrighttime(int speed,int timems) //counterclockwise turn
{
	//rotate left
	motor[driveLF] = speed;
	motor[driveLR] = speed;
	motor[driveRF] = -speed;
	motor[driveRR] = -speed;

	//wait time
	wait1Msec(timems);

	//turn off motors
	motor[driveLF] = 0;
	motor[driveLR] = 0;
	motor[driveRF] = 0;
	motor[driveRR] = 0;

}//end turn right by time



/////////////////////////////////
//
//   FIRE THE BALL
//
/////////////////////////////////
void fire()
{
	int shoottime = 1100; //time (ms) for shooter to pull back and fire

	//turn on motors to draw back puncher
	motor[shooterL] = shooterspeed;
	motor[shooterR] = shooterspeed;

	//wait the time for the drawback
	wait1Msec(shoottime);

	//turn off puncher motors
	motor[shooterL] = 0;
	motor[shooterR] = 0;

}// end fire



/////////////////////////////////
//
//   BALL LOAD CONTROL
//
/////////////////////////////////
void ball_load (int control) //intake control (both intake and conveyor)
{
	//to turn on the intake, set the parameter = 1
	//to turn it off, set the parameter = 0

	//send speed to motors, and if control is 1, result speed is the base speed set at top
	//if control is 0. the result of the calc is 0, and stops the motors
	motor[intake] = -intakespeed*control;
	motor[conveyor] = conveyorspeed*control;

}//end ball load



/////////////////////////////////
//
//      FLIPPER CONTROL
//
/////////////////////////////////
void flipper (int control) //flipper control (front flipper only)
{
	//to turn on the flipper for caps set the parameter = 1
	//to turn on the flipper for ball intake set the parameter = -1
	//to turn flipper off, set the parameter = 0

	//send speed to motors, and if control is 1, result speed is the base speed set at top
	//if control is 0, the result of the calc is 0. and stops the motors
	//if control is -1, the result is the motor runs bakward
	motor[intake] = intakespeed*control;

}// end flipper



///////////////////////////////
//
//      CONVEYOR CONTROL
//
///////////////////////////////
void conveyor_run()
{
	int conveyortime = 250; //time (ms) for conveyor to move

	//turn on motor to draw back defense bar
	motor[conveyor] = conveyorspeed;

	//wait the time for the movement/drawback
	wait1Msec(conveyortime);

	motor[conveyor] = 0;

}// end conveyor run



//*************************************************************************
//                                                                        *
//                          AUTONOMOUS FUNCTIONS                          *
//                   		(FOR EACH PART OF THE FIELD                       *
//                          OR FOR EACH TEST)                             *
//                                                                        *
//*************************************************************************

///////////////////////////////////////////////////////////
//
// Blue Far Square Autonomous Function - park or no park
//
//////////////////////////////////////////////////////////
void blue_Far()
{
	conveyor_run();//turn on conveyor to release flipper

	fire(); //fire preload

	turnLeftDeg(103,50);// turn with back to wall

	drivetime(-100,600);// back into wall

	ball_load(1); //turns intake & conveyor on

	drive(100,35);//drive to cap

	wait1Msec(10*pause);

	drive(100,-12); //back up "12 inches"

	wait1Msec(pause);

	flipper(0); //turns flipper(only) off

	turnLeftDeg(90,75);

	flipper(1); //turns flipper on(again)

	drive(100,18);// drive toward back wall

	turnRightDeg(80,75);//turn toward cap

	drive(100,26);//drive to flip cap

	drive(100,-15);//backup

	flipper(0); //turns off flipper

	if (defense == 0)// shoot middle flag
	{

		turnRightDeg(95,75);//turn toward flag

		ball_load(1); //turns intake & conveyor on

		drive(100,16);//drive to shoot

		fire();
	}
	else
	{
		turnRightDeg(57,75);

		ball_load(1);

		//drive(100,12);

		fire();
	}
	if ((park == 1) && (defense == 0))
	{
		drive(90,-2);//backup away from platform

		turnRightDeg(230,75);//rotate around

		drive(100,-35);//backup onto platform
		wait1Msec(50*pause);
	}

	else if ((park == 1) && (defense == 1))
	{
		turnLeftDeg(203,75);//rotate around

		drive(100,-55);//backup onto platform
		wait1Msec(50*pause);
	}
}// end blue far



//////////////////////////////////
//
//  Red Far Square Autonomous Function - park or no park
//
/////////////////////////////////
void red_Far()
{
	conveyor_run();//turn on conveyor to release flipper

	fire(); //fire preload

	turnRightDeg(99,50);// turn with back to wall

	drivetime(-100,600);// back into wall

	ball_load(1); //turns intake & conveyor on

	drive(100,35);//drive to cap

	wait1Msec(10*pause);

	drive(100,-12); //back up "12 inches"

	wait1Msec(pause);

	flipper(0); //turns flipper(only) off

	drive(100,-9);// backup another 3 inches

	turnRightDeg(95,75);

	flipper(1); //turns flipper on(again)

	drive(100,17);// drive toward back wall

	turnLeftDeg(95,75);//turn toward cap

	drive(100,26);//drive to flip cap

	drive(100,-15);//backup

	flipper(0); //turns off flipper

	if (defense == 0) //shoots middle flag
	{

		turnLeftDeg(100,75);//turn toward flag

		ball_load(1); //turns intake & conveyor on

		drive(100,16);//drive to shoot

		fire();
	}

	else
	{
		turnLeftDeg(65,75);//turn toward flag

		ball_load(1); //turns intake & conveyor on

		fire();
	}

	if ((park == 1) && (defense == 0))
	{
		drive(90,-2);//backup away from platform

		turnRightDeg(220,75);//rotate around

		drive(100,-35);//backup onto platform
		wait1Msec(50*pause);
	}

	else if ((park == 1) && (defense == 1))
	{
	turnRightDeg(203,75);//rotate around

		drive(100,-55);//backup onto platform
		wait1Msec(50*pause);
	}
}// end red far



//////////////////////////////////
//
//  Red Near Square Autonomous Function - park or no park
//
/////////////////////////////////
void red_Near()
{
	conveyor_run();//turn on conveyor to release flipper

	drive(75,3);//drive to shooting position

	fire(); //fire preload

	turnLeftDeg(3,75);//turn left to clear post

	drive(75,30);//drive to hit low flag

	drive(75,-12);//backup

	turnRightDeg(100,75);//rotate back to wall

	flipper(1); //turns on flipper

	drivetime(-75,650);//back into wall

	drive(75,22);//drive to flip cap

	turnRightDeg(90,75);//rotate toward platform

	drive(75,22);//drive to next cap position

	turnLeftDeg(90,75);// rotate to cap

	flipper(0); //turns off flipper

	ball_load(1); //turns intake & conveyor on

	drive(75,12);//drive to get ball from under cap

	wait1Msec(pause*6);

	turnLeftDeg(93,75);//rotate toward flags

	flipper(0); //turns flipper only off

	drive(75,12);//drive to shooting position

	fire(); //fire ball

	drive(100,-10);//drive backward

	if (park == 1)
	{
		turnLeftDeg(20,75);// line up with platform

		drive(100,-20);//back on to platform
	}
}// end red near



//////////////////////////////////
//
//  Blue Near Square Autonomous Function - park or no park
//
/////////////////////////////////
void blue_Near()
{
	conveyor_run();//run conveyor to release flipper

	drive(75,3);//drive to shooting position

	fire(); //fire preload

	drive(75,30);//drive to hit low flag

	drive(75,-10);//backup

	turnLeftDeg(70,75);//rotate back to wall

	flipper(1); //turns on flipper

	drivetime(-75,650);//backup into wall

	drive(75,22);//drive to cap

	turnLeftDeg(90,75);//rotate to head to next cap

	drive(75,22);//drive to next cap

	turnRightDeg(85,75);//rotate to next cap

	flipper(0); //turns off flipper

	ball_load(1); //turns intake & conveyor on

	drive(75,12);//drive to pickup ball

	wait1Msec(pause*10);

	turnRightDeg(93,75);//rotate to flag

	drive(75,12);//drive to shooting position

	ball_load(0); //turns intake & conveyor off

	fire(); //fire ball

	drive(100,-10);//drive backward

	if (park == 1)
	{
		turnRightDeg(20,75);// line up with platform

		drive(100,-20);//back on to platform
	}
}// end blue near



/////////////////////////////////
//
// SKILLS RUN - Far Red Square
//
/////////////////////////////////
void Skills_Far()
{
	/*conveyor_run();//run conveyor to release flipper

	fire(); //fire preload

	turnRightDeg(99,50);//turn to back wall

	drivetime(-75,650);//back into wall

	ball_load(1); //turns intake & conveyor on

	drive(75,34);//drive to pick up ball

	wait1Msec(10*pause);

	ball_load(0);

	conveyor_run();

	flipper(1);

	drive(75,12);

	drive(75,-10); //back up

	wait1Msec(pause);

	flipper(0); //turns flipper(only) off

	drive(75,-3);

	turnRightDeg(90,75);

	flipper(1); //turns flipper on(again)

	drive(75,20);

	turnLeftDeg(95,75);

	drive(75,17);

	drive(75,-10);

	flipper(0); //turns off flipper

	turnLeftDeg(95,75);

	ball_load(1); //turns intake & conveyor on

	drive(75,16);

	fire(); //fire ball

	turnRightDeg(115,75);

	drive(75,-32);

	drive(75,1);

	turnLeftDeg(75,90);

	drive(75,28);*/

	fire();

	drive(100,24);

	turnLeftDeg(90,75);

	drive(75,-45);
	wait1Msec(pause);

	drive(78,-33);
	wait1Msec(pause*60);
}



//////////////////////////////////
//
// SKILLS RUN - Near Red Square
//
/////////////////////////////////
void Skills_Near()
{
	conveyor_run();

	fire(); //fire preload

	turnRightDeg(99,50);

	drivetime(-75,650);

	ball_load(1); //turns intake & conveyor on

	drive(75,34);

	wait1Msec(10*pause);

	ball_load(0);

	conveyor_run();

	flipper(1);

	drive(75,12);

	drive(75,-10); //back up

	wait1Msec(pause);

	flipper(0); //turns flipper(only) off

	drive(75,-3);

	turnRightDeg(90,75);

	flipper(1); //turns flipper on(again)

	drive(75,20);

	turnLeftDeg(95,75);

	drive(75,17);

	drive(75,-10);

	flipper(0); //turns off flipper

	turnLeftDeg(95,75);

	ball_load(1); //turns intake & conveyor on

	drive(75,16);

	fire(); //fire ball

	turnRightDeg(115,75);

	drive(75,-32);

	drive(75,1);

	turnLeftDeg(75,90);

	drive(75,28);

	/*
	drive(75,24);

	turnLeftDeg(90,75);

	drive(75,-40);
	wait1Msec(pause);

	drive(75,-35);
	wait1Msec(pause*60);
	*/
}



//////////////////////////////////
//
//   SKILLS RUN - Red Far 2
//
/////////////////////////////////
void Skills_2()
{
	//Part One
	conveyor_run();//turn on conveyor to release flipper

	fire(); //fire preload

	turnRightDeg(99,50);// turn with back to wall

	drivetime(-75,600);// back into wall

	ball_load(1); //turns intake & conveyor on

	drive(75,38);//drive to cap

	wait1Msec(10*pause);

	flipper(0);

	wait1Msec(5*pause);

	flipper(1);

	drive(75,12);

	drive(75,-10); //back up

	wait1Msec(pause);

	flipper(0); //turns flipper(only) off

	drive(75,-20); //back up "20 inches"

	turnRightDeg(95,50);

	flipper(1); //turns flipper on(again)

	drive(75,20);// drive toward back wall

	turnLeftDeg(95,50);//turn toward cap

	drive(75,34);//drive to flip cap

	flipper(0); //turns off flipper

	drive(75,-24);//backup and hit wall

	turnLeftDeg(115,50); //turn toward flags

	//Part Two
	drive(75,18); //drive toward flags

	fire(); //fire ball

	drive(75,-4); //back up

	turnLeftDeg(110,75); //turn

	drive(75,100);

	turnRightDeg(90,50);

	drive(75,50); //drive

	turnRightDeg(90,50);

	drivetime(-75,600);

	ball_load(1); //turns intake & conveyor on

	drive(75,38);//drive to cap

	wait1Msec(10*pause);

	flipper(0);

	ball_load(1); //turns intake & conveyor on

	drive(75,38);//drive to cap

	wait1Msec(10*pause);

	flipper(0);

	//Part Three

	/*drive(75,-30);

	turnRightDeg(90,75); //turn toward cap

	flipper(1); //turn on flipper

	drive(75,48); //drive toward the cap and flip it

	flipper(0); //turn of flipper

	turnLeftDeg(90,75); //turn toward the flags

	drive(75,30); //drive forward and score low flag

	drive(75,-36); //back up

	turnLeftDeg(90,75); //turn left

	drive(75,-6); //back up

	turnRightDeg(90,75); //turn right

	drive(75,-12); //back up

	turnRightDeg(90,75); //turn toward platform

	drive(90,-78);*/
}//end of skills_2



/////////////////////////////
//
//     	Accuracy Test
//
/////////////////////////////
void accuracy()
{
	drive(100,36);//drive 36 inches
	wait1Msec(pause*10);
	turnRightDeg(100,75);//rotate 90
	wait1Msec(pause*10);
	drive(100,36);//drive 36 inches
	wait1Msec(pause*10);
	turnRightDeg(100,75);//rotate 90
	wait1Msec(pause*10);
	drive(100,36);//drive 36 inches
	wait1Msec(pause*10);
	turnRightDeg(100,75);//rotate 90
	wait1Msec(pause*10);
	drive(100,36);//drive 36 inches
	wait1Msec(pause*10);
	turnRightDeg(100,75);//rotate 90
	wait1Msec(pause*10);
	// are you back where you started???
}// end accuracy test



//*************************************************************************
//                                                                        *
//                          PRE-AUTONOMOUS FUNCTIONS                      *
//                   Menu selection to pick individual autons             *
//                                                                        *
//*************************************************************************
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	bDisplayCompetitionStatusOnLcd = false;

	// Leave this value alone; counting starts at 1
	int lcdScreenMin = 1;

	//  IMPORTANT!!!
	// Total # menu items ***** Note Adjust this to match your number of programs!!!
	int lcdScreenMax = 17;

	// Counter for what to display on the screen
	int lcdScreen = 1;

	//Turns on the Backlight
	bLCDBacklight = true;

	// Leave these values alone
	// In RobotC:
	// when the left button is pressed, nLCDButtons = 1
	// when middle button is pressed, nLCDButtons = 2
	// when right button is pressed, nLCDButtons = 4
	const short leftButton = 1;
	const short centerButton = 2;
	const short rightButton = 4;

	SensorValue(LED) = 0;// turn off LED at startup


	// This main loop will run as long at the competition
	// switch is set to ?Disabled?; When the system is
	// set to ?Enable? this loop will automatically stop.
	while (bIfiRobotDisabled == 1) {

		// This section checks whether left & right buttons are
		// pressed, and either increments or decrements the
		// lcdScreen counter; if the counter is at the max or min
		// it will loop around to the other end

		// left button
		if (nLCDButtons == leftButton) {
			if (lcdScreenMin == lcdScreen) {
				lcdScreen = lcdScreenMax;
				wait1Msec(250);
			}
			else {
				lcdScreen= lcdScreen-1;
				wait1Msec(250);
			}
		}

		// right button
		if (nLCDButtons == rightButton) {
			if (lcdScreenMax == lcdScreen) {
				lcdScreen = lcdScreenMin;
				wait1Msec(250);
			}
			else {
				lcdScreen=lcdScreen+1;
				wait1Msec(250);
			}
		}

		// The rest of pre-auton checks to see whether the middle
		// button is pressed

		// Each menu item below has 2 blocks of code, depending on
		// whether you've already selected this option, or not

		// If you have not already selected this option as
		// your choice, it will display the text normally, and will
		// then check to see if you're pressing the middle button.

		//------------------------------------------------------------//
		if (lcdScreen == 1 && autonProgram != 1) {
			displayLCDCenteredString (0, "auton 1");
			displayLCDCenteredString (1, "red_Near");

			// When you press the middle button, the screen says,
			// ?Blah blah has / been selected!? for 1.5 seconds
			// and also sets the autonProgram variable
			if (nLCDButtons == centerButton) {
				autonProgram = lcdScreen;
				park = 0;
				displayLCDCenteredString (0, "red_Near");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		// If you have already selected this item, the menu
		// text will have [square brackets] around it
		// to indicate that this is the option you?ve chosen.
		else if (lcdScreen == 1 && autonProgram == 1) {
			displayLCDCenteredString (0, "[auton 1]");
			displayLCDCenteredString (1, "[red_Near]");
		}
		//------------------------------------------------------------//
		else if (lcdScreen == 2 && autonProgram != 2) {
			displayLCDCenteredString (0, "auton 2");
			displayLCDCenteredString (1, "red_Near w-PARK");

			if (nLCDButtons == centerButton) {
				autonProgram = lcdScreen;
				park = 1;
				displayLCDCenteredString (0, "red_Near w-PARK");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 2 && autonProgram == 2) {
			displayLCDCenteredString (0, "[auton 2]");
			displayLCDCenteredString (1, "[red_Near w-PARK]");
		}
		//------------------------------------------------------------//
		else if (lcdScreen == 3 && autonProgram != 3)
		{
			displayLCDCenteredString (0, "auton 3");
			displayLCDCenteredString (1, "blue_Near");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 0;
				displayLCDCenteredString (0, "blue_Near");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 3 && autonProgram == 3) {
			displayLCDCenteredString (0, "[auton 3]");
			displayLCDCenteredString (1, "[blue_Near]");
		}
		//------------------------------------------------------------//
		else if (lcdScreen == 4 && autonProgram != 4) {
			displayLCDCenteredString (0, "auton 4");
			displayLCDCenteredString (1, "blue_Near w-PARK");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 1;
				displayLCDCenteredString (0, "blue_Near w-PARK");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 4 && autonProgram == 4)
		{
			displayLCDCenteredString (0, "[auton 4]");
			displayLCDCenteredString (1, "[blue_Near w-PARK]");
		}
		//-------------------------------------------------------------//
		else if (lcdScreen == 5 && autonProgram != 5)
		{
			displayLCDCenteredString (0,"auton 5");
			displayLCDCenteredString (1, "red_Far");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 0;
				displayLCDCenteredString (0, "red_Far");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 5 && autonProgram == 5) {
			displayLCDCenteredString (0, "[auton 5]");
			displayLCDCenteredString (1, "[red_Far]");

		}
		//---------------------------------------------------------------//
		else if (lcdScreen == 6 && autonProgram != 6)
		{
			displayLCDCenteredString (0,"auton 6");
			displayLCDCenteredString (1, "red_Far w-PARK");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 1;
				displayLCDCenteredString (0, "red_Far w-PARK");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 6 && autonProgram == 6) {
			displayLCDCenteredString (0, "[auton 6]");
			displayLCDCenteredString (1, "[red_Far w-PARK]");

		}
		//------------------------------------------------------------------//
		else if (lcdScreen == 7 && autonProgram != 7)
		{
			displayLCDCenteredString (0,"auton 7");
			displayLCDCenteredString (1, "blue_Far");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 0;
				displayLCDCenteredString (0, "blue_Far");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 7 && autonProgram == 7) {
			displayLCDCenteredString (0, "[auton 7]");
			displayLCDCenteredString (1, "[blue_Far]");
		}
		//------------------------------------------------------------------//
		else if (lcdScreen == 8 && autonProgram != 8)
		{
			displayLCDCenteredString (0,"auton 8");
			displayLCDCenteredString (1, "blue_Far w-PARK");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 1;
				displayLCDCenteredString (0, "blue_Far w-PARK");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 8 && autonProgram == 8) {
			displayLCDCenteredString (0, "[auton 8]");
			displayLCDCenteredString (1, "[blue_Far w-PARK]");
		}
		//------------------------------------------------------------------//
		else if (lcdScreen == 9 && autonProgram != 9)
		{
			displayLCDCenteredString (0,"auton 9");
			displayLCDCenteredString (1, "Skills Near");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 0;
				displayLCDCenteredString (0, "Skills Near");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 9 && autonProgram == 9) {
			displayLCDCenteredString (0, "[auton 9]");
			displayLCDCenteredString (1, "[Skills Near]");
		}

		//------------------------------------------------------------------//
		else if (lcdScreen == 10 && autonProgram != 10)
		{
			displayLCDCenteredString (0,"auton 10");
			displayLCDCenteredString (1, "Skills Far");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 0;
				displayLCDCenteredString (0, "Skills Far");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 10 && autonProgram == 10) {
			displayLCDCenteredString (0, "[auton 10]");
			displayLCDCenteredString (1, "[Skills Far]");
		}

		//------------------------------------------------------------------//
		else if (lcdScreen == 11 && autonProgram != 11)
		{
			displayLCDCenteredString (0,"auton 11");
			displayLCDCenteredString (1, "Accuracy");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 0;
				displayLCDCenteredString (0, "Accuracy");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 11 && autonProgram == 11) {
			displayLCDCenteredString (0, "[auton 11]");
			displayLCDCenteredString (1, "[Accuracy]");
		}
		//------------------------------------------------------------------//
		else if (lcdScreen == 12 && autonProgram != 12)
		{
			displayLCDCenteredString (0,"auton 12");
			displayLCDCenteredString (1, "NO AUTON");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 0;
				displayLCDCenteredString (0, "NO AUTON");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 12 && autonProgram == 12) {
			displayLCDCenteredString (0, "[auton 12");
			displayLCDCenteredString (1, "[NO AUTON]");
		}

		//------------------------------------------------------------------//
		else if (lcdScreen == 13 && autonProgram != 13)
		{
			displayLCDCenteredString (0,"auton 13");
			displayLCDCenteredString (1, "red_far_defense");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 0;
				defense = 1;
				displayLCDCenteredString (0, "red_far_defense");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 13 && autonProgram == 13) {
			displayLCDCenteredString (0, "[auton 13]");
			displayLCDCenteredString (1, "[red_far_def]");
		}
		//------------------------------------------------------------------//
		else if (lcdScreen == 14 && autonProgram != 14)
		{
			displayLCDCenteredString (0,"auton 14");
			displayLCDCenteredString (1, "red_far_def w/P");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 1;
				defense = 1;
				displayLCDCenteredString (0, "red_far_def w/P");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 14 && autonProgram == 14) {
			displayLCDCenteredString (0, "[auton 14]");
			displayLCDCenteredString (1, "[red_far_defw/P]");
		}

		//------------------------------------------------------------------//
		else if (lcdScreen == 15 && autonProgram != 15)
		{
			displayLCDCenteredString (0,"auton 15");
			displayLCDCenteredString (1, "blue_far_defense");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 0;
				defense = 1;
				displayLCDCenteredString (0, "blue_far_defense");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 15 && autonProgram == 15) {
			displayLCDCenteredString (0, "[auton 15]");
			displayLCDCenteredString (1, "[blue_far_def]");
		}
		//------------------------------------------------------------------//
		else if (lcdScreen == 16 && autonProgram != 16)
		{
			displayLCDCenteredString (0,"auton 16");
			displayLCDCenteredString (1, "blue_far_def w/P");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				park = 1;
				defense = 1;
				displayLCDCenteredString (0, "blue_far_def w/P");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 16 && autonProgram == 16) {
			displayLCDCenteredString (0, "[auton 16]");
			displayLCDCenteredString (1, "[blue_far_d w/P]");
		}

		//------------------------------------------------------------------//
		else if (lcdScreen == 17 && autonProgram != 17)
		{
			displayLCDCenteredString (0,"auton 17");
			displayLCDCenteredString (1, "Skills_2");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				displayLCDCenteredString (0, "Skills_2");
				displayLCDCenteredString (1, "is selected!");
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 17 && autonProgram == 17) {
			displayLCDCenteredString (0, "[auton 17]");
			displayLCDCenteredString (1, "[Skills_2]");
		}


		//------------------------------------------------------------------//
		// this last menu option does not set the autonProgram
		// variable, but rather displays the value of a sensor
		// that is useful for the drive team to see in pre-auton
		//else if (lcdScreen == ? ) {
		//displayLCDCenteredString (0,"Ultrasonic Val");
		//displayLCDNumber(1, 0,SensorValue[myUltrasonic], -1);
		//}

	}	// end of while-disabled loop
}// end of pre-auton



//*************************************************************************
//                                                                        *
//                          MAIN AUTONOMOUS TASK                          *
//                   THIS RUNS THE CORRECT AUTONOMOUS FUCNTION            *
//                   BASED ON THE ITEM SELECTED IN THE PRE-AUTON MENU     *
//                                                                        *
//*************************************************************************
task autonomous()//This is the begining of the Autonomous Code
{
	if((autonProgram == 1) || (autonProgram == 2))
	{
		red_Near();
	}
	else if((autonProgram == 3) || (autonProgram == 4))
	{
		blue_Near();
	}
	else if((autonProgram == 5) || (autonProgram == 6) || (autonProgram == 13) || (autonProgram == 14))
	{
		red_Far();
	}
	else if((autonProgram == 7) || (autonProgram == 8) || (autonProgram == 15) || (autonProgram == 16))
	{
		blue_Far();
	}
	else if(autonProgram == 9)
	{
		Skills_Near();
	}
	else if (autonProgram == 10)
	{
		Skills_Far();
	}
	else if (autonProgram == 11)
	{
		accuracy();
	}
	else if (autonProgram == 12)
	{
		// do nothing
	}
	else if (autonProgram == 17)
	{
		Skills_2();
	}
}//End of Autonomous



//*************************************************************************
//                                                                        *
//             INDIVDUAL TASKS FOR EACH DRIVER CONTROL OPTION             *
//       Driver control is multitasking.  Each major function on the      *
//           robot has its own task based on its joystick control         *
//               or its function in the driver control portion            *
//*************************************************************************
task driverscreen()//  display items on the screen to allow for diagnosis
{
	// Leave this value alone; counting starts at 1
	int driverScreenMin = 1;

	//  IMPORTANT!!!
	// Total # menu items ***** Note Adjust this to match your number of screens!!!
	int driverScreenMax = 6;

	// Counter for what to display on the screen
	int driverScreen = 1;

	//Turns on the Backlight
	bLCDBacklight = true;

	// Leave these values alone
	// In RobotC:
	// when the left button is pressed, nLCDButtons = 1
	// when middle button is pressed, nLCDButtons = 2
	// when right button is pressed, nLCDButtons = 4
	const short leftButton = 1;
	const short centerButton = 2;
	const short rightButton = 4;

	string mainBattery, expBattery, lencdist, fusonic, rusonic, lusonic;


	// This section checks whether left & right buttons are
	// pressed, and either increments or decrements the
	// lcdScreen counter; if the counter is at the max or min
	// it will loop around to the other end
	while(1==1)
	{
		// left button
		if (nLCDButtons == leftButton) {
			if (driverScreenMin == driverScreen) {
				driverScreen = driverScreenMax;
				wait1Msec(250);
			}
			else {
				driverScreen= driverScreen-1;
				wait1Msec(250);
			}
		}

		// right button
		if (nLCDButtons == rightButton) {
			if (driverScreenMax == driverScreen) {
				driverScreen = driverScreenMin;
				wait1Msec(250);
			}
			else {
				driverScreen=driverScreen+1;
				wait1Msec(250);
			}
		}

		//------------------------------------------------------------
		if (driverScreen == 1) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString (0, 0, "LEnc: ");
			displayNextLCDNumber(SensorValue(encoderL));
			displayLCDString (1, 0, "REnc: ");
			displayNextLCDNumber(SensorValue(encoderR));
		}
		//------------------------------------------------------------
		else if (driverScreen == 2 ) {
			clearLCDLine(0);
			clearLCDLine(1);

			//Display the Primary Robot battery voltage
			displayLCDString(0, 0, "MBat: ");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
			displayNextLCDString(mainBattery);

			//Display the Backup battery voltage
			displayLCDString(1, 0, "EBat: ");
			sprintf(expBattery, "%1.2f%c", SensorValue(expBatt)/280.0, 'V');	//Build the value to be displayed
			displayNextLCDString(expBattery);

			//Short delay for the LCD refresh rate
			wait1Msec(100);
		}
		//------------------------------------------------------------
		else if (driverScreen == 3) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString (0, 0, "LEnc: ");
			displayNextLCDNumber(SensorValue(encoderL));
			displayLCDString (1, 0, "Dist: ");
			sprintf(lencdist, "%3.2f", SensorValue(encoderL)*cir/360);
			displayNextLCDString(lencdist);

			if (nLCDButtons == centerButton) {
				SensorValue(encoderL) = 0;
				SensorValue(encoderR) = 0;
			}
		}
		//------------------------------------------------------------
		else if (driverScreen == 4) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDCenteredString (0, "Front Ultrasonic");
			sprintf(fusonic, "%3.2f", SensorValue(front));
			displayLCDCenteredString (1, fusonic);
		}
		//------------------------------------------------------------
		else if (driverScreen == 5) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDCenteredString (0, "Left Ultrasonic");
			sprintf(lusonic, "%3.2f", SensorValue(left));
			displayLCDCenteredString (1, lusonic);
		}

		//------------------------------------------------------------
		else if (driverScreen == 6) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDCenteredString (0, "Right Ultrasonic");
			sprintf(rusonic, "%3.2f", SensorValue(right));
			displayLCDCenteredString (1, rusonic);
		}
	}
	//------------------------------------------------------------
}// end while loop for screen
//} // end driver screen



////////////////////////////////////////////////////////////////////////////////////////
//                                                                                    //
//                          S P E A K E R  C O N T R O L                              //
//                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////
/*task speakercontrol()
{
	while (1 == 1)

	if (vexRT[Btn6UXmtr2] == 1) //when button 8U is pressed
	{
		playSoundFile ("Fire.wav"); //play sound
		bPlaySounds = true;
		wait1Msec(pause*20);
	}
	else if (vexRT[Btn7U] == 1)
	{
		playSoundFile ("Charlie5.0.wav");
		bPlaySounds = true;
		wait1Msec(pause*20);
	}

	else if (vexRT[Btn7R] == 1)
	{
		playSoundFile ("Defensebar.wav");
		bPlaySounds = true;
		wait1Msec(pause*20);
	}
}// end of speaker control task

*/

////////////////////////////////////////////////////////////////////////////////////////
//                                                                                    //
//                       S H O O T E R  C O N T R O L                                 //
//                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////
task shootercontrol()
{
	while (1==1)
	{
		if (vexRT[Btn6UXmtr2] == 1)
		{
			motor[shooterL] = 127;
			motor[shooterR] = 127;
		}

		else
		{
			motor[shooterL] = 0;
			motor[shooterR] = 0;
		}
	}// end shooter while loop
}// end of shooter control



/////////////////////////////////////////////////////////////////////////////////////
//                                                                                 //
//                           I N T A K E  C O N T R O L                            //
//                                                                                 //
/////////////////////////////////////////////////////////////////////////////////////
task intakecontrol()
{
	while (1==1)
	{
		if (vexRT[Btn5UXmtr2] == 1 & vexRT[Btn5DXmtr2] == 0) //When top button is pressed and bottom isn't, run forward//
		{
			motor[intake] = 127;
		}

		else if (vexRT[Btn5UXmtr2] == 0 & vexRT[Btn5DXmtr2] == 1) //When top button isn't pressed and bottom is, run backward//

		{
			motor[intake] = -127;
		}

		else
		{
			motor[intake] = 0;
		}
	}// end intake while loop
}// end intake control



/////////////////////////////////////////////////////////////////////////////////////
//                                                                                 //
//                        C O N V E Y O R  C O N T R O L                           //
//                                                                                 //
/////////////////////////////////////////////////////////////////////////////////////
task conveyorcontrol()
{
	SensorValue(LED) = 0;// turn off LED at start of program, and outside loop
	while (1==1)
	{
		if (SensorValue(limitswitch) == 0)
		{
			SensorValue(LED) = 1;
			clearTimer(T1);
		}
		if ((time1(T1)>800)&& (SensorValue(limitswitch)==1))
		{
			SensorValue(LED) = 0;
		}
		if (vexRT[Btn7UXmtr2] == 1 & vexRT[Btn7DXmtr2] == 0) //When top button is pressed and bottom isn't, run up//
		{
			motor[conveyor] = 125;
		}

		else if (vexRT[Btn7UXmtr2] == 0 & vexRT[Btn7DXmtr2] == 1) //When top button isn't pressed and bottom is, run down//

		{
			motor[conveyor] = -125;
		}

		else
		{
			motor[conveyor] = 0;
		}
	} // end conveyor while loop
}  // end conveyor control



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control the robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
task usercontrol()
{
	//Start other user/driver tasks to run the robot
	startTask(shootercontrol);
	startTask(intakecontrol);
	startTask(conveyorcontrol);
	startTask(driverscreen);
	//  startTask(speakercontrol);
	//	startTask(defensecontrol);
	//	startTask(armcontrol);

	while (1==1)
		//Main user/driver chassis control loop here

	/*------------------------------------------------------------------------*/
	/*                                                                        */
	/*                         Chassis Control                                */
	/*                  This is used to control our chassis                   */
	/*                                                                        */
	/*------------------------------------------------------------------------*/
	{
		motor [driveLF] = (abs(vexRT[Ch3])>20)*vexRT [Ch3]; // motor drive left is controlled by channel 3
		motor [driveLR] = (abs(vexRT[Ch3])>20)*vexRT [Ch3]; // motor drive left is controlled by channel 3
		motor [driveRF] = (abs(vexRT[Ch2])>20)*vexRT [Ch2]; // motor drive right is controlled by channel 2
		motor [driveRR] = (abs(vexRT[Ch2])>20)*vexRT [Ch2]; // motor drive right is controlled by channel 2
	} // end driver while loop
} //End of user control
